use crate::{error::SculkParseError, traits::FromCompoundNbt, util::get_owned_string};

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Jigsaw {
    /// The block that this jigsaw block becomes.
    pub final_state: String,

    /// The joint option value, either "rollable" or "aligned".
    pub joint: JigsawJoint,

    /// The jigsaw block's name. This jigsaw block gets aligned with another structure's jigsaw block that has this value in the target tag.
    pub name: String,

    /// The jigsaw block's target pool to select a structure from.
    pub pool: String,

    /// The jigsaw block's target name. This jigsaw block gets aligned with another structure's jigsaw block that has this value in the name tag.
    pub target: String,

    /// Priority of this jigsaw block being selected for generation. Jigsaw blocks with higher selection priority get selected first.
    pub selection_priority: i32,

    /// Priority of the piece generated by this jigsaw block to place its children. Pieces with higher placement priority generate their children first.
    pub placement_priority: i32,
}

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(from = "&str", into = "&str"))]
pub enum JigsawJoint {
    Rollable,
    Aligned,
}

impl From<&str> for JigsawJoint {
    fn from(s: &str) -> Self {
        match s {
            "rollable" => JigsawJoint::Rollable,
            "aligned" => JigsawJoint::Aligned,
            _ => panic!("Invalid jigsaw joint value: {}", s),
        }
    }
}

impl From<JigsawJoint> for &str {
    fn from(j: JigsawJoint) -> Self {
        match j {
            JigsawJoint::Rollable => "rollable",
            JigsawJoint::Aligned => "aligned",
        }
    }
}

impl FromCompoundNbt for Jigsaw {
    fn from_compound_nbt(
        nbt: &simdnbt::borrow::NbtCompound,
    ) -> Result<Self, crate::error::SculkParseError>
    where
        Self: Sized,
    {
        let final_state = get_owned_string(&nbt, "final_state")?;
        let joint = nbt
            .string("joint")
            .map(|s| JigsawJoint::from(s.to_str().as_ref()))
            .ok_or(SculkParseError::MissingField("joint".into()))?;

        let name = get_owned_string(&nbt, "name")?;
        let pool = get_owned_string(&nbt, "pool")?;
        let target = get_owned_string(&nbt, "target")?;
        let selection_priority = nbt
            .int("selection_priority")
            .ok_or(SculkParseError::MissingField("selection_priority".into()))?;
        let placement_priority = nbt
            .int("placement_priority")
            .ok_or(SculkParseError::MissingField("placement_priority".into()))?;

        Ok(Jigsaw {
            final_state,
            joint,
            name,
            pool,
            target,
            selection_priority,
            placement_priority,
        })
    }
}
